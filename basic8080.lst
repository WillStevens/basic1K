0000                          ; Will Stevens
0000                          ; 25th Feb 2023
0000                          ; 1K 8080 BASIC
0000                          ; 
0000                          ; Post-assembly checklist
0000                          ; 
0000                          ; 1. LineNumSub is >= address 223h
0000                          ; 2. DivSub is at address 2xxh (i.e. <= 2ffh)
0000                          ; 3. DivJzError is at address 3xxh
0000                          ; 4. In LineStartsWithInt, the jump to
0000                          ;    DeleteProgramLine is on the same
0000                          ;    page as DeleteProgramLine
0000                          ; 5. Program does not exceed 1k
0000                          ; 6. In ClassLookup, check that QuoteClass
0000                          ;    has LSB different from othet class subs
0000                          ; 
0000                          ; 2023-03-03 About 450 bytes long
0000                          ; 2023-03-08 About 750 bytes long
0000                          ; 2023-03-11 About 840 bytes long
0000                          ; 2023-03-12 About 930 bytes long.
0000                          ;   String tokens added.
0000                          ;   * and / yet to be added.
0000                          ;   Some scope for size optimization.
0000                          ; 2023-03-12 About 940 bytes long
0000                          ;		* added
0000                          ;		some reduction in code size done
0000                          ; 2023-03-16 About 970 bytes long
0000                          ;   unsigned / and integer output added
0000                          ;		about 30 bytes could be saved
0000                          ;		by using RST in place of call
0000                          ;   in some places
0000                          ; 2023-03-17 About 940 bytes long
0000                          ; 2023-03-17 About 970 bytes long
0000                          ;		INPUT added
0000                          ; 2023-03-19 About 960 bytes long
0000                          ;    some bug fixes
0000                          ;		 capable of playing lunar lander
0000                          ; 2023-03-22 About 970 bytes long
0000                          ;		 signed / added
0000                          ; 2023-03-24 About 950 bytes long
0000                          ;		 more code size reductions
0000                          ;		 signed integer parsing supported
0000                          ; 2023-03-24 About 940 bytes long
0000                          ;    more code size reductions
0000                          ; 2023-03-27 About 950 bytes long
0000                          ;		 simplified operator calling and
0000                          ;		 simplified a few operators
0000                          ;		 working on memory rotate function needed
0000                          ;		 for line deletion and insertion
0000                          ; 2023-04-09 About 970 bytes long.
0000                          ;		 more code size reductions
0000                          ;		 first draft of memory rotate function added
0000                          ; 2023-04-12 About 995 bytes long
0000                          ;		 line deletion function more complete
0000                          ;		 looking for better way of decreasing
0000                          ;		 PROG_PTR after line deletion
0000                          ; 2023-04-16 About 986 bytes long
0000                          ;    line deletion apparently working
0000                          ;    some code size reductions
0000                          ; 2023-04-16 About 963 bytes long
0000                          ;			further code size reductions
0000                          ; 2023-04-17 About 930 bytes long
0000                          ;			looked for subroutine code sharing and
0000                          ;			LXI trick optimisations.
0000                          ;			Likely that some bugs will have been
0000                          ;			introduced when doing this
0000                          ; 2023-04-18 About 900 bytes long
0000                          ;			greatly reduced CharClass size
0000                          ; 2023-04-20 About 880 bytes long
0000                          ;			more code size reduction
0000                          ; 2023-04-23 About 970 bytes long
0000                          ;			first draft of code for LIST added
0000                          ; 2023-04-25 About 970 bytes long
0000                          ;			LIST command working
0000                          ; 2023-04-27 About 950 bytes long
0000                          ;			More code size reduction
0000                          ; 2023-04-28 About 950 bytes long
0000                          ;			used RST_CompareJump to save
0000                          ;			2 bytes for every CPI JZ where
0000                          ;			the jump is to same page
0000                          ; 2023-04-28 Free space: 78 bytes
0000                          ; 2023-04-29 Free space: 84 bytes
0000                          ;			Initialise PROG_PTR at start
0000                          ;			Added NEW and END
0000                          ;			Added direct statement handling
0000                          ; 2023-04-30 Free space: 86 bytes
0000                          ;			Fixed bugs with deleting first and
0000                          ;			last program lines
0000                          ; 2023-05-02 Free space: about 60 bytes
0000                          ;			added code to allow out-of-order
0000                          ;			line number entry (first draft)
0000                          ; 2023-05-02 Free space: about 54 bytes
0000                          ;			all basic functionality now implemented
0000                          ;			items to improve:
0000                          ;			division
0000                          ;			syntax checking
0000                          ; 2023-05-04 Free space: about 79 bytes
0000                          ;			more code size reduction
0000                          ;			partly through handling EndProgram
0000                          ;			and LineNum better in threaded code
0000                          ;			likely to have introduced bugs
0000                          ; 2023-05-07 Free space: about 69 bytes
0000                          ;			Improved expression evaluation by
0000                          ;			making it recursively callable
0000                          ;			and no longer requiring operator stack
0000                          ;			and about 20 bytes shorter.
0000                          ;			Used freed space for more syntax checks
0000                          ; 2023-05-08 Free space: about 44 bytes
0000                          ;			First draft of support for array var @
0000                          ; 2023-05-17 Free space: About 100 bytes
0000                          ;			First draft of new parser from
0000                          ;			experiments/parsing3.asm.
0000                          ;			Still need to modify string representation
0000                          ;			and change how INPUT parses integer,
0000                          ;			and check string token doesn't interfere
0000                          ;			after TokenList, and check order in
0000                          ;			TokenList.
0000                          ;			Seems likely that enough space has been
0000                          ;			freed to be able to implement FOR...NEXT
0000                          ; 2023-05-19 Free space: About 101 bytes
0000                          ;			Issues listed above have been addressed now
0000                          ;			Testing needed to iron out problems
0000                          ; 2023-05-26 Free space: About 84 bytes
0000                          ;			various bug fixes
0000                          ;			PRINT allows comma at end to suppress
0000                          ;			newline.
0000                          ;			Show > prompt symbol when ready.
0000                          ; 2023-05-27 Free space: About 17 bytes
0000                          ;			Added FOR NEXT (no STEP yet)
0000                          ;			Need more space
0000                          ; 2023-05-27 Free space: About 36 bytes
0000                          ;			Made a few small byte savings, and put
0000                          ;			token subs onto page 2 so that last one
0000                          ;			can flow onto page 3, freeing some space
0000                          ;			in page 2 to avoid having to jump out.
0000                          ;			One TODO to action
0000                          ; 2023-05-28 Free space: About 42 bytes
0000                          ; 2023-05-29 Free space: About 53 bytes
0000                          ;			Made some changes to * and / which I hope
0000                          ;			are improvements (efficienxy + code size)
0000                          ;			but testing needed to confirm this.
0000                          ; 2023-06-02 Free space: About 12 bytes
0000                          ;			Added support for STEP to FOR loops
0000                          ;			Noted where Z flag is in known state
0000                          ;			in JMP instructions, because there is
0000                          ;			potential space saving by having
0000                          ;			2-byte in-page JMP, JNZ or JZ,
0000                          ;			code shared with RST_CompareJump
0000                          ; 2023-06-03 Free space: About 10 bytes
0000                          ;			STEP works in +ve direction only
0000                          ;			Fixing will require more space
0000                          ;			Would also like to add ABS, RND, USR
0000                          ;			But probably need about 60 bytes for that
0000                          ; 2023-06-03 Free space: About 19 bytes
0000                          ;			Added in-page JZ to free up space
0000                          ;			Likely to have introduced errors
0000                          ; 2023-06-04 Free space: About 25 bytes
0000                          ;			Shortened PrintSub
0000                          ; 2023-06-04 Free space: about -21 bytes
0000                          ;			Implementing ABS and USR and skeleton
0000                          ;		  of RND makes it 21 bytes over budget.
0000                          ;			So it seems reasonable to think that
0000                          ;			space can be made for these.
0000                          ; 2023-06-05 Free space: about -15 bytes
0000                          ; 2023-06-19 Free space: about 6 bytes
0000                          ;			Replaced memory rotate with triple reversal
0000                          ;			algorithm. Back below size limit, but need
0000                          ;		  to rearrange things to realize this.
0000                          ; 2023-06-22 Free space: about 10 bytes
0000                          ;			All free space is in the RST area, which I
0000                          ;     am reluctant to use because I expect that
0000                          ;			when I try to target actual hardware I will
0000                          ;			need to extend PutChar, and maybe have
0000                          ;			some initialization code for e.g. UART.
0000                          ;			So discounting this I am 2 bytes over
0000                          ;			budget, and haven't implemented RND
0000                          ;			function yet
0000                          ; 2023-06-23 Free space : 18 bytes
0000                          ;			Saved space with more sharing between
0000                          ; 		LET and INPUT
0000                          ;			Ready to do a lot of testing
0000                          ; 2023-06-28 Free space : 20 bytes
0000                          ; 2023-06-28 Free space : 19 bytes
0000                          ;			Fixed enough bugs that lunar lander works
0000                          ;			Function calls don't work yet
0000                          ; 2023-07-01 Free space : 24 bytes
0000                          ;			ABS function works
0000                          ;			RND function currently does nothing
0000                          ;			need to make implementation of RND
0000                          ;			that fits in 17 bytes
0000                          ; 2023-07-04 Free space : 20 bytes
0000                          ;			Implemented simple lookup-based RND
0000                          ;			replaced newline RST with LDAX B, INX B
0000                          ;			saved a few bytes in LIST
0000                          ; 2023-07-05 Free space : 11 bytes
0000                          ;			Implemented XORSHIFT RND function
0000                          ; 2023-07-08 Free space: 10 bytes
0000                          ; 2023-07-12 Free space: 15 bytes
0000                          ;			Fixed forgotten issue where STEP in FOR
0000                          ;			loop didn't work if negative
0000                          ; 2023-07-13 Free space: 13 bytes
0000                          ;			Extended variable range up to 32
0000                          ;			So that user has 31 variables and array
0000                          ;			var 30 can be used to work out
0000                          ;			remaining memory
0000                          ;			var 31 is RNG seed
0000                          ; 2023-07-15 Noticed bug where -32768 isn't
0000                          ;     displayed
0000                          ; 2023-07-15 When playing REVERSE, saw corrupted
0000                          ;			array, which implies that bug where stack
0000                          ;			continually growing
0000                          ; 2023-07-16 Above two issues fixed. Former
0000                          ;     required change to PrintInteger. Latter
0000                          ;			was due to a GOTO from within FOR loop,
0000                          ;			in REVERSE and not necessarily a problem
0000                          ;			with this interpreter
0000                          ; 2024-01-01 Fixed bug where parse error wasn't
0000                          ;     displayed as ? during LIST
0000                          ; 2024-01-28 Fixed bug where @ was displayed as M
0000                          ;     during LIST
0000                          ; 2024-02-07 Working on corrections to comparison
0000                          ;     operators. Not in working state. Made I/O
0000                          ;     compatible with Dick Whipple's Front Panel
0000                          ;     8080 simulator
0000                          ; 2024-02-08 May have fixed comparison operator
0000                          ;     problem. Need to save 2 bytes to be able to
0000                          ;     test it
0000                          ; 2024-02-08 Reclaimed some space so that 3FEh is
0000                          ;     the last byte uses. Free space 5 bytes.
0000                          ; 2024-02-18 Worked towards reclaiming 4 bytes in
0000                          ;     the tokenizer. Good chance of being
0000                          ;     incorrect, will require debugging.
0000                          ; 2024-02-20 Debugged above changes and
0000                          ;     they seem okau. Free space 9 bytes
0000                          ; 2024-02-22 Rearranged RSTs and added CPI to end
0000                          ;     of RST_LDAXB_INXB_CPI to save memory.
0000                          ;     Free space still 9 bytes but now
0000                          ;     7 of those are at the end of 1K, so are
0000                          ;     easy to make use of.
0000                          ;     Need to check movement and alignment
0000                          ;     of subroutines.
0000                          ;     It would be useful to have a checklist of
0000                          ;     all dependencies that need to be checked
0000                          ;     when there are large movements in memory.
0000                          ; 
0000                          ;     Next things to do:
0000                          ;     - unterminated string check
0000                          ;     - forbidding excess chars in tokens
0000                          ;     - correct operator precedence for * /
0000                          ;     - error on divide by zero
0000                          ;     not sure whether all 4 can be done in
0000                          ;     only 7 bytes
0000                          ; 2024-02-25 Added unterminated string check and
0000                          ;     didvide by zero error. 2 bytes over budget.
0000                          ; 2024-02-25 Realised that removing reatriction
0000                          ;     that RUN, LIST and NEW only allowed in
0000                          ;     direct mode would will probably save a
0000                          ;     sufficient number of bytes to finish all
0000                          ;     outstanding work
0000                          ; 2024-02-28 Sveral changes related to issues
0000                          ;     listed above, Divide by zero and
0000                          ;     unterminated string now generate error
0000                          ;     messages. 2 bytes free which should be
0000                          ;     enough to make * and / equal precedence,
0000                          ;     but will test everything else first. Issue
0000                          ;     about tokens with excess chars not being
0000                          ;     detected as errors will remain unfixed in
0000                          ;     first release.
0000                          ; 2024-03-01 Found bug where recent changes
0000                          ;     caused DeleteProgramLine to move page.
0000                          ;     In the course of fixing it, may have saved
0000                          ;     5 bytes. Need to test that fix is correct.
0000                          ; 2024-03-01 Fixed a bug introduced on 28 Feb
0000                          ;     where ExecuteDirect was called without
0000                          ;     setting B. Wrote 'game of life' example
0000                          ;     program. When printing newline, added CR
0000                          ;     before after discovering that some
0000                          ;     terminals need this. Need to free up
0000                          ;     1 byte to fix operator precedence issue
0000                          ; 2024-03-02 This version correcly runs
0000                          ;     lander.bas, reverse.bas, life.bas,
0000                          ;     operatortests.bas, operatortests2.bas,
0000                          ;     looptests.bas
0000                          ; 2024-03-02 Freed up 1 byte by removing
0000                          ;     redundant STC
0000                          ; 2024-03-03 Added code to make * same
0000                          ;     precedence as / (needs testing).
0000                          ;     Changed RNG from XORSHIFT to LCG.
0000                          ;     This saved 3 bytes.
0000                          ;     Need to experiment with LCG constant
0000                          ;     for best RNG performance.
0000                          ;     Behaviour of RNG function changed so
0000                          ;     that max valid input parameter is 256,
0000                          ;     because low order bits of RNG have
0000                          ;     low period. Only high ordet bits of
0000                          ;     RNG are used for return value.
0000                          ; 2024-03-04 Altered EndProgram address.
0000                          ;     Temporarily tried making RAM start at 1000h
0000                          ;     to check that this doesn't cause problems
0000                          ; 2024-03-06 Changed IO to support Stefan Tramms
0000                          ;     8080 emulator.
0000                          ; 2024-03-08 Branches code to make Altaid 8800
0000                          ;     version.
0000                          ; For development purposes assume we have
0000                          ; 1K ROM from 0000h-03FFh containing BASIC
0000                          ; 1K RAM from 1000h-13FFh
0000                RAM_BASE:   EQU   1000h   
0000                RAM_TOP:   EQU   1400h   
0000                          ; Token values
0000                          ; 0-31 are variables (0 = @)
0000                          ; IntegerToken must be one more than last var
0000                INTEGERTOKEN:   EQU   32   
0000                QUESTIONMARKTOKEN:   EQU   33   
0000                STRINGTOKEN:   EQU   34   
0000                          ; Callable tokens are low byte of subroutine to call
0000                          ; Errors are displayed as Ex where x is an error
0000                          ; code which is tbe address on the stack when
0000                          ; Error subroutine is called.
0000                          ; Input buffer is just 8 bytes long
0000                          ; used by input statement to get an integer.
0000                          ; If there is a buffer overflow because user
0000                          ; enters too much, the behaviour is system
0000                          ; dependent - e.g. if writes above RAM
0000                          ; space do nothing then its not a problem.
0000                          ; If memory space repeats and lower 1K
0000                          ; is ROM then also not much of a problem.
0000                INPUT_BUFFER:   EQU   RAM_TOP-8   
0000                STACK_INIT:   EQU   RAM_TOP-8   
0000                          ; this must be on a 256 byte boundary
0000                VAR_SPACE:   EQU   RAM_BASE   
0000                          ; 30 words, first of which is not
0000                          ; accessible to user, so can be
0000                          ; used for PROG_PTR
0000                PROG_PTR:   EQU   RAM_BASE   
0000                          ; 2 words accessible to user as variables
0000                          ; 30 and 31 (^ and _)
0000                PROG_PARSE_PTR:   EQU   RAM_BASE+60   
0000                RNG_SEED:   EQU   RAM_BASE+62   
0000                PROG_BASE:   EQU   RAM_BASE+64   
0000                          .ORG   00h   
0000                          ; I would like this to be:
0000                          ; LXI H,PROG_BASE
0000                          ; SHLD PROG_PTR
0000                          ; JMP Ready
0000                          ; 
0000                          ; But this doesn't fit in 8 bytes.
0000                          ; Instead we find a place in the program
0000                          ; that has LXI B,PROG_BASE, and set SP to that
0000                          ; address, the POP H from the stack and
0000                          ; store it in PROG_PTR, then INX SP means
0000                          ; that when we fall through to PutChar,
0000                          ; the RET will jump to Ready
0000                          ; 
0000                          ; (It means that on reset and NEW a char
0000                          ; will be output that depends on the value of
0000                          ; A at the time, but worth it to save several
0000                          ; bytes)
0000   31 91 02               LXI   SP,ExecuteProgram+2   
0003   E1                     POP   H   
0004   22 00 10               SHLD   PROG_PTR   
0007   33                     INX   SP   
0008                          .ORG   08h   
0008                          ; PutChar is called frequently
0008                          ; PutChar must return with Z set
0008                PUTCHAR:   
0008                          ; port 1 is for char I/O
0008   D3 01                  OUT   1   
000A                PUTCHARWAITLOOP:   ; address 000ah
000A                          ; TODO change these fee instructions
000A                          ; if targetting hardware
000A   AF                     XRA   A   
000B   C9                     RET   
000C                          ;IN 1
000C   E6 40                  ANI   040h   
000E   C8                     RZ   
000F   C3                     DB   0c3h   ; opcode for JMP
0010                          ; the following two bytes are
0010                          ; 0ah and 00h, so this jumps to
0010                          ; PutCharWaitLoop
0010                          ; 
0010                          .ORG   10h   
0010   0A                     LDAX   B   ; opcode 0ah
0011   00                     NOP   ; opcode 00h
0012   03                     INX   B   
0013   E3                     XTHL   
0014   BE                     CMP   M   
0015   23                     INX   H   
0016   E3                     XTHL   
0017   C9                     RET   
0018                          ; 
0018                          .ORG   18h   
0018                          ; byte after RST is compared with A
0018                          ; if equal then jump to address on same page.
0018                          ; 
0018                          ; only use where performance is not
0018                          ; important (parsing, printing)
0018   E3                     XTHL   
0019   BE                     CMP   M   
001A   23                     INX   H   
001B   C3 21 00               JMP   CompareJump_Entry   
001E                          ; 
001E                          ; 2 bytes free
0020                          .ORG   20h   
0020   E3                     XTHL   
0021                COMPAREJUMP_ENTRY:   
0021   C2 25 00               JNZ   JZPage_Skip   
0024   6E                     MOV   L,M   
0025                JZPAGE_SKIP:   
0025   23                     INX   H   
0026                EXPAPPLYOP:   ; shared code
0026   E3                     XTHL   
0027   C9                     RET   
0028                          .ORG   28h   
0028                COMPAREHLDE:   
0028                          ; compare HL and DE, return
0028                          ; Z equal, NZ if not equal
0028                          ; C equal, NC if not equal
0028                          ; A will be zero if Z is set
0028   7D                     MOV   A,L   
0029   AB                     XRA   E   
002A   C0                     RNZ   
002B   7C                     MOV   A,H   
002C   AA                     XRA   D   
002D   C0                     RNZ   
002E   37                     STC   
002F   C9                     RET   
0030                          .ORG   30h   
0030                NEGATEDE:   
0030                          ;flags are not affected
0030                          ; 
0030                          ; decrement and invert so that we end
0030                          ; up with D in A - sometimes handy
0030   1B                     DCX   D   
0031   7B                     MOV   A,E   
0032   2F                     CMA   
0033   5F                     MOV   E,A   
0034   7A                     MOV   A,D   
0035   2F                     CMA   
0036   57                     MOV   D,A   
0037   C9                     RET   
0038                          .ORG   38h   
0038                          ; Leave space for JMP to ISR
0038   00 00 00               DB   0,0,0   
003B                EXPEVALUATE:   
003B                          ; BC points to program
003B                          ; DE contains value
003B                          ; Stack is used for both operands and
003B                          ; operators
003B                          ; This puts a marker on the stack to
003B                          ; detect when there are operators on the
003B                          ; stack - operators all have 2 as the hi byte
003B                          ; but this call puts hi byte 0 on the stack
003B   CD 42 00               CALL   ExpEvaluateNum   
003E   D4 0A 04               CNC   Error   
0041   C9                     RET   
0042                          ; ExpEvaluateNum must always be called
0042                          ; from page 0
0042                EXPEVALUATENUM:   
0042                          ; Expecting ( var integer or - sign
0042                          ; or function call
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
0042   D7 RST   2   
0043   B1                     DB   LeftBraceToken&0ffh   
        **MACRO UNROLL - RST_JZPAGE
0044   E7 RST   4   
0045   C3                     DB   (ExpLeftBrace&0ffh)-1   
        **MACRO UNROLL - RST_COMPAREJUMP
0046   DF RST   3   
0047   E4 76                  DB   SubSub&0xff,(ExpNegate&0ffh)-1   
0049                          ; 
0049                          ; last function
0049   FE B5                  CPI   (RndSub+1)&0ffh   
004B   D0                     RNC   ; if its greater than this, its an error
004C                          ; first function
004C   FE AE                  CPI   AbsSub&0ffh   
004E   D2 C5 00               JNC   FunctionCall   ; between RndSub and AbsSub
0051                          ; 
0051                          ; can't use RST_CompareJump below
0051                          ; because it doesn't preserve Carry after
0051                          ; comparison.
0051                          ; TODO - this assumption isn't correct - INX H
0051                          ; doesnt affect flags
0051                          ; 
0051   FE 20                  CPI   IntegerToken   
0053   DA 5B 00               JC   ExpVar   
0056                          ; 
0056                          ; Integer token is one more than last var
0056                          ; token so if carry is set then it is a var
0056                          ; 
0056   C0                     RNZ   : return with carry clear if error   
0057                          ; Fall through to ExpInteger
0057                EXPINTEGER:   
0057   60                     MOV   H,B   
0058   69                     MOV   L,C   
0059   03                     INX   B   
005A   03                     INX   B   
005B                          ; 
005B                          ; fall through with carry clear
005B                EXPVAR:   
005B                          ; carry set if jumped to here
005B                          ; 
005B   DC AD 00               CC   GetVarLocation   
005E                EXPVARGETVALUE:   
005E   5E                     MOV   E,M   
005F   23                     INX   H   
0060   56                     MOV   D,M   
0061                EXPEVALUATEOP:   
0061                          ;Expecting operator or right bracket or
0061                          ;end of expression
0061                          ; 
0061                          ;Are there operators on the stack?
0061   E1                     POP   H   
0062                          ; 
0062                          ; H will be 0 if no operators on
0062                          ; stack (i.e. high byte of return address)
0062                          ; 
0062   7C                     MOV   A,H   
        **MACRO UNROLL - RST_COMPAREJUMP
0063   DF RST   3   
0064   00 6F                  DB   0,(SkipExpApplyOp&0ffh)-1   
0066                          ; 
0066                          ; if L is equal to MulSub then apply it.
0066                          ; this gives * same precedence as /
0066   7D                     MOV   A,L   
        **MACRO UNROLL - RST_COMPAREJUMP
0067   DF RST   3   
0068   E8 25                  DB   (MulSub&0ffh),(ExpApplyOp&0ffh)-1   
006A                          ; 
006A   0A                     LDAX   B   
006B                          ; 
006B                          ; No longer needed since case below
006B                          ; includes this
006B                          ;CPI Operators&0ffh
006B                          ; Is it the end of the expression?
006B                          ;JC ExpApplyOp
006B                          ; 
006B                          ; Does operator on stack have GTE precedence?
006B                          ; (or end of expression, when A < operators)
006B   3D                     DCR   A   
006C   BD                     CMP   L   
006D                          ; 
006D   DA 26 00               JC   ExpApplyOp   ; apply the operator
0070                          ; that was on the stack
0070                          ; 
0070                SKIPEXPAPPLYOP:   
0070   E5                     PUSH   H   ; put operator that was on stack
0071                          ; back onto stack
0071                          ; 
0071   0A                     LDAX   B   
0072                          ; 
0072   FE CB                  CPI   Operators&0ffh   
0074                          ; Is it the end of the expression?
0074   D8                     RC   
0075                          ; 
0075   03                     INX   B   
0076                          ; 
0076                          ; Code shared with ExpNegate
0076                          ; so use a CPI to mop up the initial
0076                          ; LXI in ExpNegate
0076                          ; 
0076   FE                     DB   0feh   ; OpCode for CPI to mop up LXI
0077                EXPNEGATE:   
0077                          ; Put 0 onto stack and - onto
0077                          ; operator stack
0077   11 00 00               LXI   D,0   
007A                          ; 
007A   21 61 00               LXI   H,ExpEvaluateOp   ; address to return to
007D                          ; after operator is called
007D   E5                     PUSH   H   
007E                          ; 
007E   D5                     PUSH   D   ; operand
007F   6F                     MOV   L,A   ; operator address
0080   26 02                  MVI   H,PrintSub/256   
0082   E5                     PUSH   H   
0083                          ; 
0083   C3 42 00               JMP   ExpEvaluateNum   
0086                PRINTSUBSTRING:   
0086   CD BC 00               CALL   OutputString   ; carry is clear on return
0089                PRINTSUBINTEGER:   ; carry is set on jump to here
0089   DC 8C 01               CC   PrintInteger   ; carry is clear on return
008C                          ; 
008C   11                     DB   11h   ; LXI D eats 2 bytes
008D                PRINTSUBLOOP:   
008D   37                     STC   
008E   03                     INX   B   
008F   D1                     POP   D   ; discard, since we are about to push again
0090                          ; 
0090                PRINTSUBIMPL:   
0090                          ; First time called, carry is clear
0090                          ; Subsequent times carry is clear unless
0090                          ; last token was a comma
0090   F5                     PUSH   PSW   
0091                          ; 
0091   0A                     LDAX   B   
0092                          ; 
        **MACRO UNROLL - RST_COMPAREJUMP
0092   DF RST   3   
0093   22 85                  DB   StringToken,(PrintSubString&0ffh)-1   
        **MACRO UNROLL - RST_COMPAREJUMP
0095   DF RST   3   
0096   AC 8C                  DB   CommaToken,(PrintSubLoop&0ffh)-1   
0098                          ; must be called from page 0
0098   CD 42 00               CALL   ExpEvaluateNum   
009B   DA 89 00               JC   PrintSubInteger   
009E   0B                     DCX   B   
009F                          ; 
009F                          ; Finished, we want to print a newline unless
009F                          ; last one was a comma
009F   F1                     POP   PSW   
00A0   D8                     RC   ; return without newline if it was comma
00A1                CRLF:     
00A1   3E 0D                  MVI   A,13   
        **MACRO UNROLL - RST_PUTCHAR
00A3   CF RST   1   
00A4   3E 0A                  MVI   A,10   
        **MACRO UNROLL - RST_PUTCHAR
00A6   CF RST   1   
00A7   C9                     RET   
00A8                GETVARLOCATIONBVAR:   
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
00A8   D7 RST   2   
00A9                          ; Test that we have a var
00A9   20                     DB   32   
00AA   D4 0A 04               CNC   Error   
00AD                GETVARLOCATION:   
00AD                          ; A should contain a var token
00AD                          ; and B points to tbe location after
00AD                          ; the var token
00AD                          ; return with var address in HL
00AD                          ; and B pointing to next char
00AD                          ; A will never be 255 on return
00AD   26 10                  MVI   H,VAR_SPACE/256   
00AF   87                     ADD   A   
00B0   6F                     MOV   L,A   
00B1                          ; 
00B1   C0                     RNZ   
00B2                          ; 
00B2                          ; fall through if it is array var
00B2                          ; 
00B2   CD CD 00               CALL   ExpBracketedB   
00B5                          ; 
00B5                          ; Now DE contains the array index
00B5                          ; Add it twice to get the offset
00B5                          ; 
00B5   2A 3C 10               LHLD   PROG_PARSE_PTR   
00B8   23                     INX   H   ; up 1 byte to avoid EndProgram marker
00B9   19                     DAD   D   
00BA   19                     DAD   D   
00BB                OUTPUTSTRINGRET:   ; shared code, nearest RET
00BB   C9                     RET   
00BC                          ; This 9 byte routine can be moved anywhere to
00BC                          ; fill holes
00BC                OUTPUTSTRING:   
00BC                          ;Pointer in B points to string token marker
00BC   03                     INX   B   
00BD                OUTPUTSTRINGLOOP:   
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
00BD   D7 RST   2   
00BE   22                     DB   StringToken   
        **MACRO UNROLL - RST_JZPAGE
00BF   E7 RST   4   
00C0   BA                     DB   (OutputStringRet&0ffh)-1   
00C1                OUTPUTSTRING_WITHQUOTE:   
        **MACRO UNROLL - RST_PUTCHAR
00C1   CF RST   1   
        **MACRO UNROLL - RST_JZPAGE
00C2   E7 RST   4   
00C3   BC                     DB   (OutputStringLoop&0ffh)-1   
00C4                EXPLEFTBRACE:   
00C4   0B                     DCX   B   
00C5                FUNCTIONCALL:   
00C5                          ; push return address
00C5   11 61 00               LXI   D,ExpEvaluateOp   
00C8   D5                     PUSH   D   
00C9                          ; A contains the address to call on page 2
00C9                          ; push function address
00C9   6F                     MOV   L,A   
00CA   26 02                  MVI   H,PrintSub/256   
00CC   E5                     PUSH   H   
00CD                          ; 
00CD                          ; fall through
00CD                          ; This must be before Error so that it
00CD                          ; can fall through
00CD                EXPBRACKETEDB:   
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
00CD   D7 RST   2   
00CE   B1                     DB   LeftBraceToken&0ffh   
00CF   C4 0A 04               CNZ   Error   
00D2   CD 3B 00               CALL   ExpEvaluate   
00D5                          ; 
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
00D5   D7 RST   2   
00D6   AB                     DB   RightBraceToken&0ffh   
00D7   C8                     RZ   
00D8                          ; 
00D8                          ; fall through
00D8                          ;Display error code and go back to line entry
00D8   C3 0A 04               JMP   Error   
00DB                          ; fall through
00DB                          ; 
00DB                READY:    
00DB                          ; Set stack pointer
00DB                          ; Do this every time to guard against
00DB                          ; GOSUB with no RETURN errors
00DB                          ; 
00DB   31 F8 13               LXI   SP,STACK_INIT   
00DE                          ; 
00DE   CD A1 00               CALL   CRLF   
00E1                          ; 
00E1   2A 00 10               LHLD   PROG_PTR   
00E4   E5                     PUSH   H   ; push it because we need it after
00E5                          ; GetLine
00E5   CD 28 03               CALL   GetLine   
00E8                          ; 
00E8   36 90                  MVI   M,EndProgram&0ffh   
00EA                          ; 
00EA   22 3C 10               SHLD   PROG_PARSE_PTR   
00ED   E1                     POP   H   
00EE                          ; 
00EE   E5                     PUSH   H   
00EF   C1                     POP   B   
00F0                          ; 
00F0   7E                     MOV   A,M   
00F1                          ; Regardless of which branch taken
00F1                          ; we need this marker here.
00F1                          ; This overwrites the token to execute,
00F1                          ; but we've already got that in A
00F1   36 90                  MVI   M,EndProgram&0ffh   
00F3                          ; 
00F3   FE 20                  CPI   IntegerToken   
00F5   C2 97 02               JNZ   ExecuteDirect   
00F8                          ; 
00F8                LINESTARTSWITHINT:   
00F8                          ; Get the line number into DE
00F8   23                     INX   H   
00F9   5E                     MOV   E,M   
00FA   23                     INX   H   
00FB   56                     MOV   D,M   
00FC   23                     INX   H   
00FD                          ; 
00FD                          ; Is it an integer all by itself?
00FD                          ; If so then delete the line
00FD                          ; 
00FD                          ; call GetLineNum to find either the line, or
00FD                          ; pointer to next location in program after it
00FD                          ; 
00FD   66                     MOV   H,M   ; preserve M (GetLineNum doesn't touch H)
00FE   CD BB 03               CALL   GetLineNum   
0101   7C                     MOV   A,H   
0102   2A 00 10               LHLD   PROG_PTR   
0105   F5                     PUSH   PSW   
0106                          ; 
        **MACRO UNROLL - RST_COMPAREJUMP
0106   DF RST   3   
0107   90                     DB   EndProgram&0ffh   
0108   18                     DB   (DeleteProgramLine&0ffh)-1   
0109                          ; 
0109   F1                     POP   PSW   
010A                          ; if GetLineNum returns a match then this is
010A                          ; an error, user must delete line first
010A   CC 0A 04               CZ   Error   
010D                          ; 
010D                          ; do a memory rotate with
010D                          ; first = GetLine/ATNLN address
010D                          ; middle = PROG_PTR
010D                          ; last = PROG_PARSE_PTR
010D                          ; 
010D   36 27                  MVI   M,LineNumSub&0ffh   ; undo what we did earlier
010F   EB                     XCHG   
0110   2A 3C 10               LHLD   PROG_PARSE_PTR   
0113                          ; 
0113   E5                     PUSH   H   ; last
0114   C5                     PUSH   B   ; first
0115                          ; 
0115   D5                     PUSH   D   ; middle
0116                          ; 
0116   AF                     XRA   A   
0117                          ; 
        **MACRO UNROLL - RST_JZPAGE
0117   E7 RST   4   
0118   28                     DB   (Entry&0ffh)-1   
0119                DELETEPROGRAMLINE:   
0119                          ; 25 bytes
0119   F1                     POP   PSW   
011A                          ; 
011A   C2 DB 00               JNZ   Ready   ; if line not found, do nothing
011D   E5                     PUSH   H   
011E   C5                     PUSH   B   ; first
011F   E5                     PUSH   H   ; last
0120                          ; 
0120   09                     DAD   B   ; HL=PROG_PTR+first
0121                          ; 
0121   03                     INX   B   
0122   CD D6 03               CALL   ATNLN_Int   ; Z is set when this is called
0125                          ; 
0125                          ;set HL to what we want PROG_PTR to be
0125   50                     MOV   D,B   
0126   59                     MOV   E,C   
        **MACRO UNROLL - RST_NEGATEDE
0127   F7 RST   6   
0128                          ; 
0128   19                     DAD   D   ; HL=PROG_PTR+first-middle
0129                          ; 
0129                          ; because DAD D above always causes HL
0129                          ; to decrease, it must set carry
0129                          ; so STC below is not needed
0129                          ;STC ; skip first reverse in memory rotate
0129                          ; because we don't care about the
0129                          ; line being deleted
0129                          ; 
0129                ENTRY:    
0129                          ; carry is clear if coming from insert
0129                          ; 
0129   C5                     PUSH   B   ; middle (or first)
012A   22 00 10               SHLD   PROG_PTR   
012D                          ; 
012D                MEMORYROTATE:   
012D                          ; 27 bytes
012D                          ; stack must contain (from top down)
012D                          ; first, middle, first, last
012D                          ; DE = middle
012D                          ; HL = Last
012D   D4 3A 01               CNC   Reverse   
0130   CD 37 01               CALL   ReverseDH   
0133   01 DB 00               LXI   B,Ready   
0136   C5                     PUSH   B   
0137                REVERSEDH:   
0137   E1                     POP   H   
0138   D1                     POP   D   
0139   E3                     XTHL   
013A                REVERSE:   
013A                          ; HL = last (i.e 1 after the last byte to swap)
013A                          ; DE = first
013A                REVERSELOOP:   
        **MACRO UNROLL - RST_COMPAREHLDE
013A   EF RST   5   
013B   C8                     RZ   
013C   2B                     DCX   H   
        **MACRO UNROLL - RST_COMPAREHLDE
013D   EF RST   5   
013E   C8                     RZ   
013F                          ; 
013F   46                     MOV   B,M   
0140   1A                     LDAX   D   
0141   77                     MOV   M,A   
0142   78                     MOV   A,B   
0143   12                     STAX   D   
0144   13                     INX   D   
0145                          ; 
0145   C3 3A 01               JMP   ReverseLoop   
0148                POPHASSIGNTOVAR_PREFIX:   
0148   E5                     PUSH   H   
0149                          ; 
0149   CD 28 03               CALL   GetLine   
014C   C1                     POP   B   
014D   CD 3B 00               CALL   ExpEvaluate   
0150   C1                     POP   B   
0151                          ; fall through
0151                POPHASSIGNTOVAR:   
0151   E1                     POP   H   
0152                          ; 
0152                          ; Put DE into var (HL)
0152                          ; 
0152   73                     MOV   M,E   
0153   23                     INX   H   
0154   72                     MOV   M,D   
0155                          ; 
0155   C9                     RET   
0156                LISTLOOP:   
0156   3E 20                  MVI   A,' '   
        **MACRO UNROLL - RST_PUTCHAR
0158   CF RST   1   
0159                          ; 
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
0159   D7 RST   2   
015A   90                     DB   EndProgram&0ffh   
015B   C8                     RZ   
015C                          ; 
015C   21 56 01               LXI   H,ListLoop   ; so that we can loop using RET
015F   E5                     PUSH   H   
0160                          ; H is already set to the correct page
0160   2E B3                  MVI   L,(TokenList-1)&0ffh   
0162                          ; These need to be on same page
0162                          ; currently on page 3
        **MACRO UNROLL - RST_COMPAREJUMP
0162   DF RST   3   
0163   22 AB                  DB   StringToken,(List_String&0ffh)-1   
        **MACRO UNROLL - RST_COMPAREJUMP
0165   DF RST   3   
0166   27 82                  DB   LinenumSub&0ffh,(List_Linenum&0ffh)-1   
        **MACRO UNROLL - RST_COMPAREJUMP
0168   DF RST   3   
0169   20 85                  DB   IntegerToken,(List_Integer&0ffh)-1   
016B   DA B0 01               JC   List_Var   
016E                          ; No need to check for end of TokenList
016E                          ; impossible not to be a token value in A
016E                LIST_TOKEN_LOOP:   
016E   56                     MOV   D,M   
016F   14                     INR   D   
0170   23                     INX   H   
0171   F2 6E 01               JP   List_Token_Loop   
0174                LIST_TOKEN:   
0174                          ; on entry, A contains the token
0174                          ; so must not use A during this loop
0174   BE                     CMP   M   
0175   23                     INX   H   
0176   C2 6E 01               JNZ   List_Token_Loop   
0179                          ; 
0179                LIST_TOKEN_STRING_LOOP:   
0179   7E                     MOV   A,M   
017A   E6 7F                  ANI   07fh   
        **MACRO UNROLL - RST_PUTCHAR
017C   CF RST   1   
017D   B6                     ORA   M   
017E   23                     INX   H   
017F   F2 79 01               JP   List_Token_String_Loop   
0182   C9                     RET   
0183                          ; 
0183                LIST_LINENUM:   
0183   CD A1 00               CALL   CRLF   
0186                LIST_INTEGER:   
0186   0A                     LDAX   B   
0187   03                     INX   B   
0188   5F                     MOV   E,A   
0189   0A                     LDAX   B   
018A   03                     INX   B   
018B   57                     MOV   D,A   
018C                          ; fall through to PrintInteger
018C                          ; 
018C                          ;Output the value in DE
018C                PRINTINTEGER:   
018C   AF                     XRA   A   
018D   F5                     PUSH   PSW   ; end marker is Z flag
018E                          ; 
018E   B2                     ORA   D   ; S is set if -ve
        **MACRO UNROLL - RST_NEGATEDE
018F   F7 RST   6   
0190                          ; 
0190   F2 97 01               JP   PrintIntegerLoop   
0193   3E 2D                  MVI   A,'-'   
        **MACRO UNROLL - RST_PUTCHAR
0195   CF RST   1   
        **MACRO UNROLL - RST_NEGATEDE
0196   F7 RST   6   
0197                          ; 
0197                PRINTINTEGERLOOP:   
0197                          ; need HL to be -ve here, so that it can
0197                          ; handle -32768
0197                          ; 
0197   EB                     XCHG   
0198   11 0A 00               LXI   D,10   
019B                          ; 
019B   CD FC 02               CALL   DivideHL   
019E                          ; HL contains remainder after / 10
019E                          ; DE contains the quotient
019E   3E 30                  MVI   A,'0'   
01A0   95                     SUB   L   
01A1   F5                     PUSH   PSW   ; push onto stack
01A2                          ; 
01A2                          ; if DE is zero we are done
01A2   7A                     MOV   A,D   
01A3   B3                     ORA   E   
01A4   C2 97 01               JNZ   PrintIntegerLoop   
01A7                          ; 
01A7                PRINTINTEGERLOOP2:   
01A7   F1                     POP   PSW   
01A8   C8                     RZ   
        **MACRO UNROLL - RST_PUTCHAR
01A9   CF RST   1   
        **MACRO UNROLL - RST_JZPAGE
01AA   E7 RST   4   
01AB   A6                     DB   (PrintIntegerLoop2&0ffh)-1   
01AC                LIST_STRING:   
01AC   CD C1 00               CALL   OutputString_WithQuote   
01AF   11                     DB   011h   ; LXI D skips 2 bytes
01B0                LIST_VAR:   
01B0   C6 40                  ADI   '@'   
        **MACRO UNROLL - RST_PUTCHAR
01B2   CF RST   1   
01B3   C9                     RET   ; byte before TokenList must have high bit set
01B4                          ; Index to subroutine address must not overlap with other tokens
01B4                          ; Currently TokenList starts toward the end
01B4                          ; of page 1, and DivSub begins towards the end
01B4                          ; of page 2 and the subroutine extends into page 3
01B4                          ; order in this list must make sure that a
01B4                          ; token A that is a left substring of another
01B4                          ; token B appears later in the list than B
01B4                          ; e.g. < is after <=
01B4                          ; 
01B4                TOKENLIST:   
01B4   21                     DB   QuestionMarkToken&0ffh   
01B5   BF                     DB   '?'+128   
01B6   2A                     DB   PrintSub&0ffh   
01B7   50 52 49 4E D4         DB   "PRIN",'T'+128   
01BC   57                     DB   LetSub&0ffh   
01BD   4C 45 D4               DB   "LE",'T'+128   
01C0   34                     DB   GotoSub&0ffh   
01C1   47 4F 54 CF            DB   "GOT",'O'+128   
01C5   2D                     DB   GosubSub&0ffh   
01C6   47 4F 53 55 C2         DB   "GOSU",'B'+128   
01CB   3E                     DB   ReturnSub&0ffh   
01CC   52 45 54 55 52 CE      DB   "RETUR",'N'+128   
01D2   48                     DB   InputSub&0ffh   
01D3   49 4E 50 55 D4         DB   "INPU",'T'+128   
01D8   53                     DB   ForSub&0ffh   
01D9   46 4F D2               DB   "FO",'R'+128   
01DC   66                     DB   NextSub&0ffh   
01DD   4E 45 58 D4            DB   "NEX",'T'+128   
01E1   86                     DB   IfSub&0ffh   
01E2   49 C6                  DB   "I",'F'+128   
01E4   93                     DB   EndSub&0ffh   
01E5   45 4E C4               DB   "EN",'D'+128   
01E8                          ; 
01E8                          ; Before this are keywords allowed at run-time
01E8   8F                     DB   ExecuteProgram&0ffh   
01E9   52 55 CE               DB   "RU",'N'+128   
01EC   A8                     DB   ListSub&0ffh   
01ED   4C 49 53 D4            DB   "LIS",'T'+128   
01F1   A7                     DB   NewSub&0ffh   
01F2   4E 45 D7               DB   "NE",'W'+128   
01F5                          ; 
01F5                          ; 
01F5                          ; 
01F5                          ; before operators are non-statement
01F5                          ; non-operator tokens
01F5   AE                     DB   AbsSub&0ffh   
01F6   41 42 D3               DB   "AB",'S'+128   
01F9   B2                     DB   UsrSub&0ffh   
01FA   55 53 D2               DB   "US",'R'+128   
01FD   B4                     DB   RndSub&0ffh   
01FE   52 4E C4               DB   "RN",'D'+128   
0201                          ; 
0201   A9                     DB   ToToken&0ffh   
0202   54 CF                  DB   "T",'O'+128   
0204   AA                     DB   StepToken&0ffh   
0205   53 54 45 D0            DB   "STE",'P'+128   
0209   AC                     DB   CommaToken   
020A   AC                     DB   ","+128   
020B   B1                     DB   LeftBraceToken&0ffh   
020C   A8                     DB   '('+128   
020D   AB                     DB   RightBraceToken&0ffh   
020E   A9                     DB   ')'+128   
020F   D9                     DB   EqualSub&0ffh   
0210   BD                     DB   '='+128   
0211   DC                     DB   NotEqualSub&0ffh   
0212   3C BE                  DB   "<",'>'+128   
0214   CC                     DB   GTESub&0ffh   
0215   3E BD                  DB   ">",'='+128   
0217   CB                     DB   LTESub&0ffh   
0218   3C BD                  DB   "<",'='+128   
021A   D0                     DB   LTSub&0ffh   
021B   BC                     DB   '<'+128   
021C   CF                     DB   GTSub&0ffh   
021D   BE                     DB   '>'+128   
021E   E3                     DB   AddSub&0ffh   
021F   AB                     DB   '+'+128   
0220   E4                     DB   SubSub&0ffh   
0221   AD                     DB   '-'+128   
0222   E8                     DB   MulSub&0ffh   
0223   AA                     DB   '*'+128   
0224   FC                     DB   DivSub&0ffh   
0225   AF                     DB   '/'+128   
0226   FF                     DB   255   ; 255 can only occur at the end
0227                          ; 
0227                LINENUMSUB:   
0227   03                     INX   B   
0228   03                     INX   B   
0229   C9                     RET   
022A                          ; 
022A                PRINTSUB:   
022A   C3 90 00               JMP   PrintSubImpl   
022D                          ; 
022D                GOSUBSUB:   
022D   CD 3B 00               CALL   ExpEvaluate   
0230   E1                     POP   H   
0231                          ; 
0231   C5                     PUSH   B   
0232   E5                     PUSH   H   
0233                          ; 
0233   11                     DB   011h   ; opcode for LXI H to eat 2 bytes
0234                          ; because ExpEcaluate is on page
0234                          ; 0, third byte is NOP
0234                GOTOSUB:   
0234   CD 3B 00               CALL   ExpEvaluate   
0237   CD BB 03               CALL   GetLineNum   
023A   C8                     RZ   
023B   CD 0A 04               CALL   Error   
023E                          ; TODO in place of call error, is there
023E                          ; a two or three byte inst that will
023E                          ; cause C to be set when DAD SP is called below?
023E                          ; 
023E                RETURNSUB:   
023E                          ; Expect stack size to be 6 or more
023E                          ; any less and we have return without gosub
023E   21 0D EC               LXI   H,-(STACK_INIT-6)-1   
0241   39                     DAD   SP   
0242   DC 0A 04               CC   Error   
0245                          ; 
0245   E1                     POP   H   ; Get return address first
0246   C1                     POP   B   ; Get pointer to program loc to return to
0247   E9                     PCHL   ; instead of RET
0248                INPUTSUB:   
0248   CD A8 00               CALL   GetVarLocationBVar   
024B   E5                     PUSH   H   
024C   21 F8 13               LXI   H,INPUT_BUFFER   
024F   C5                     PUSH   B   
0250                          ; 
0250   C3 48 01               JMP   POPHAssignToVar_Prefix   
0253                FORSUB:   
0253   21 E9 03               LXI   H,ForSubImpl   
0256   E5                     PUSH   H   
0257                          ; fall through to LetSub
0257                          ; First part is just like let statement
0257                LETSUB:   
0257   CD A8 00               CALL   GetVarLocationBVar   
025A   E5                     PUSH   H   
025B                          ; 
025B                          ; Test that we have an equals sign
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
025B   D7 RST   2   
025C                          ; 
025C   D9                     DB   EqualSub&0ffh   
025D   C4 0A 04               CNZ   Error   
0260                          ; 
0260   CD 3B 00               CALL   ExpEvaluate   
0263                          ; 
0263   C3 51 01               JMP   POPHAssignToVar   
0266                          ; 
0266                NEXTSUB:   
0266   E1                     POP   H   ; discard return address
0267                          ; stack contains VL+1,S,-T,LS,EPL
0267   E1                     POP   H   ; get VL+1
0268   56                     MOV   D,M   
0269   2B                     DCX   H   
026A   5E                     MOV   E,M   
026B                          ; 
026B   E3                     XTHL   ; step is in HL, VL is in (SP)
026C   EB                     XCHG   ; step is in DE, var value in HL
026D   19                     DAD   D   ; add step onto var
026E   EB                     XCHG   ; result is in DE, step is in HL
026F   E3                     XTHL   ; step is in (SP), VL is in HL
0270                          ; 
0270   73                     MOV   M,E   ; put back into VL
0271   23                     INX   H   ; H = VL+1
0272   72                     MOV   M,D   
0273                          ; 
0273   F1                     POP   PSW   ; get step so that hi bit of A has
0274                          ; sign of step
0274   E1                     POP   H   ; get -T
0275                          ; 
0275   19                     DAD   D   ; HL now has LV-T
0276                          ; 
0276   AC                     XRA   H   ; xor sign of step with
0277                          ; sign of result
0277                          ; 
0277                          ; if result of xor above is 1
0277                          ; then keep looping, or if HL
0277                          ; is zero then keep looping
0277                          ; 
0277   D1                     POP   D   ; this is LoopStart
0278                          ; 
0278   FA 7E 02               JM   NextSubLoop   
027B                          ; 
027B   7C                     MOV   A,H   
027C   B5                     ORA   L   
027D   C0                     RNZ   
027E                          ; 
027E                NEXTSUBLOOP:   
027E                          ; 
027E   42                     MOV   B,D   
027F   4B                     MOV   C,E   
0280   21 F6 FF               LXI   H,-10   
0283   39                     DAD   SP   
0284   F9                     SPHL   
0285                          ; 
0285   C9                     RET   
0286                          ; 
0286                IFSUB:    
0286   CD 3B 00               CALL   ExpEvaluate   
0289   7A                     MOV   A,D   
028A   B3                     ORA   E   
028B   C0                     RNZ   
028C                          ; If DE zero then fall through to next line
028C   C3 D8 03               JMP   AdvanceToNextLineNum   
028F                EXECUTEPROGRAM:   
028F   37                     STC   ; skip over JNC Ready in a minute
0290                          ; 
0290                ENDPROGRAM:   ; executes the JNC Ready
0290                          ; don't care what happens to BC
0290                          ; if we are jumping to Ready
0290                          ; 
0290                          ; Point BC to first line
0290                          ; Don't skip over the line number
0290                          ; because we need the constant PROG_BASE
0290                          ; at this location in memory
0290   01 40 10               LXI   B,PROG_BASE   
0293                ENDSUB:   
0293   D2 DB 00               JNC   Ready   
0296                EXECUTEPROGRAMLOOP:   
0296   0A                     LDAX   B   
0297                          ; 
0297                EXECUTEDIRECT:   
0297                          ; 
0297   D6 27                  SUI   LineNumSub&0ffh   
0299                          ; 
0299                          ; Check that it is a token between
0299                          ; LinenumSub and ListSub
0299   FE 82                  CPI   (ListSub-LineNumSub+1)&0ffh   
029B   D4 0A 04               CNC   Error   
029E                          ; 
029E   03                     INX   B   
029F   C6 27                  ADI   LineNumSub&0ffh   
02A1                          ; 
02A1                          ; Carry is clear now
02A1                          ; 
02A1                          ; Put return address onto stack
02A1   21 96 02               LXI   H,ExecuteProgramLoop   
02A4   E5                     PUSH   H   
02A5                          ; 
02A5                          ; Put pointer to call address into HL
02A5   6F                     MOV   L,A   
02A6                          ; ExecuteProgramLoop must be on the same page
02A6                          ; page as PrintSub so that we don't have to
02A6                          ; update H
02A6                          ; Jump to it
02A6                          ; Carry is clear when we do this
02A6   E9                     PCHL   
02A7                NEWSUB:   
02A7   C7                     RST   0   
02A8                          ; 
02A8                LISTSUB:   
02A8   01 40 10               LXI   B,PROG_BASE   
02AB   C3 56 01               JMP   ListLoop   
02AE                          ; 
02AE                          ; ( ) , TO STEP tokens must have values between
02AE                          ; statements and functions
02AE                TOTOKEN:   EQU   ListSub+1   
02AE                STEPTOKEN:   EQU   ListSub+2   
02AE                RIGHTBRACETOKEN:   EQU   ListSub+3   
02AE                COMMATOKEN:   EQU   ListSub+4   
02AE                ABSSUB:   
02AE                          ; A = right brace token, which has high bit
02AE                          ; set, so no need to negate DE if XRA with D
02AE                          ; still leaves high bit set
02AE   AA                     XRA   D   
02AF   F8                     RM   
        **MACRO UNROLL - RST_NEGATEDE
02B0   F7 RST   6   
02B1                          ; 
02B1                          ; shared code. okay for this to go here
02B1                          ; because in ExpEvaluateNum, test for
02B1                          ; left brace is before test for token
02B1                          ; between first and last function
02B1                LEFTBRACETOKEN:   
02B1   C9                     RET   
02B2                          ; 
02B2                USRSUB:   
02B2   EB                     XCHG   
02B3   E9                     PCHL   
02B4                RNDSUB:   
02B4                          ; LCG
02B4                          ; don't use low byte in return value.
02B4                          ; Multiplier 47989 is mentioned here:
02B4                          ; https://groups.google.com/g/prng/c/evszGs76o1w?pli=1
02B4   D5                     PUSH   D   
02B5   2A 3E 10               LHLD   RNG_SEED   
02B8   11 75 BB               LXI   D,47989   
02BB   CD E8 02               CALL   MulSub   ; A is zero after this
02BE   EB                     XCHG   
02BF   23                     INX   H   
02C0   22 3E 10               SHLD   RNG_SEED   
02C3                          ; Use only the high byte to get a value
02C3                          ; between 0 and 255
02C3   6C                     MOV   L,H   
02C4   67                     MOV   H,A   
02C5   D1                     POP   D   
02C6                          ; 
02C6   CD FC 02               CALL   DivideHL   
02C9   EB                     XCHG   
02CA   C9                     RET   
02CB                          ; XORSHIFT taken from here
02CB                          ; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Random
02CB                          ;LHLD RNG_SEED
02CB                          ;MOV A,H
02CB                          ;RAR
02CB                          ;MOV A,L
02CB                          ;RAR
02CB                          ;XRA H
02CB                          ;MOV H,A
02CB                          ;MOV A,L
02CB                          ;RAR
02CB                          ;MOV A,H
02CB                          ;RAR
02CB                          ;XRA L
02CB                          ;MOV L,A
02CB                          ;XRA H ; clears carry
02CB                          ;MOV H,A
02CB                          ;SHLD RNG_SEED
02CB                          ; carry is clear at this point
02CB                          ;RAR
02CB                          ;MOV H,A
02CB                          ; above 2 bytes give us a value between
02CB                          ; 0 and 32767
02CB                          ;CALL DivideHL
02CB                          ;XCHG
02CB                          ;RET
02CB                          ; Token values >= this are all operators
02CB                OPERATORS:   
02CB                          ; 
02CB                LTESUB:   
02CB                          ; Swap operands and fall through
02CB   EB                     XCHG   
02CC                GTESUB:   
        **MACRO UNROLL - RST_COMPAREHLDE
02CC   EF RST   5   
        **MACRO UNROLL - RST_JZPAGE
02CD   E7 RST   4   
02CE   D9                     DB   (BinReturn&0ffh)-1   
02CF                GTSUB:    
02CF                          ; Swap operands and fall through
02CF   EB                     XCHG   
02D0                LTSUB:    
02D0   7D                     MOV   A,L   
02D1   93                     SUB   E   
02D2   7C                     MOV   A,H   
02D3   9A                     SBB   D   
02D4   1F                     RAR   
02D5   AC                     XRA   H   
02D6   AA                     XRA   D   
02D7   17                     RAL   
02D8   3E                     DB   3eh   ; MVI A opcode to swallow next byte
02D9                EQUALSUB:   
        **MACRO UNROLL - RST_COMPAREHLDE
02D9   EF RST   5   ; returns Z iff HL=DE
02DA                BINRETURN:   
02DA   3F                     CMC   
02DB   3E                     DB   3eh   ; MVI A opcode to swallow next byte
02DC                          ; 
02DC                NOTEQUALSUB:   
        **MACRO UNROLL - RST_COMPAREHLDE
02DC   EF RST   5   ; returns Z iff HL=DE
02DD   11 01 00               LXI   D,1   
02E0   D0                     RNC   
02E1   1B                     DCX   D   
02E2   C9                     RET   
02E3                ADDSUB:   
02E3   3E                     DB   3eh   ; opcode for MVI A, to eat next byte
02E4                SUBSUB:   
        **MACRO UNROLL - RST_NEGATEDE
02E4   F7 RST   6   
02E5                          ;Add DE to HL and keep in DE
02E5   19                     DAD   D   
02E6   EB                     XCHG   
02E7                          ; 
02E7   C9                     RET   
02E8                MULSUB:   
02E8                          ; 20 bytes
02E8                          ; multiple HL and DE into DE, preserving B
02E8   C5                     PUSH   B   
02E9   44                     MOV   B,H   
02EA   4D                     MOV   C,L   
02EB                MULTIPLY:   
02EB                          ;multiply BC and DE into DE
02EB   3E 10                  MVI   A,16   
02ED                MULLOOP:   
02ED   29                     DAD   H   
02EE   EB                     XCHG   
02EF   29                     DAD   H   
02F0   EB                     XCHG   
02F1   D2 F5 02               JNC   DontAdd   
02F4   09                     DAD   B   
02F5                DONTADD:   
02F5   3D                     DCR   A   
02F6   C2 ED 02               JNZ   MulLoop   
02F9                          ; 
02F9   EB                     XCHG   
02FA   C1                     POP   B   
02FB   C9                     RET   
02FC                          ; 
02FC                DIVSUB:   
02FC                          ; 31 bytes
02FC                          ;Divide HL by DE
02FC                          ;Remainder in HL
02FC                          ;Result in DE
02FC                DIVIDEHL:   
02FC                          ;Divide HL by DE
02FC                          ; Make HL and DE different signs
02FC   7C                     MOV   A,H   
02FD   CD AE 02               CALL   AbsSub   
0300   F5                     PUSH   PSW   
0301                          ; 
0301                          ;Divide HL by DE
0301                          ;Assuming that HL and DE are different signs
0301   C5                     PUSH   B   
0302   01 FF FF               LXI   B,0ffffh   
0305                          ; 
0305                          ; Do the test for zero here because we want the
0305                          ; CZ to be on page 3
0305                          ; This means that divide by zero and unterminated
0305                          ; string both have tbe same error code, but kt
0305                          ; will be obvious to the programmer which is
0305                          ; intended
0305   7A                     MOV   A,D   
0306   B3                     ORA   E   
0307                DIVJZERROR:   
0307   CC 0A 04               CZ   Error   
030A                          ; 
030A                DIVLOOP:   
030A   03                     INX   B   
030B   19                     DAD   D   
030C   1F                     RAR   ; look for mismatch between carry and
030D                          ; bit 7 of D to detect overflow/underflow
030D   AA                     XRA   D   
030E   F2 0A 03               JP   DivLoop   
0311                          ; if HL is zero then it must have been a negative number originally, and the remainder is zero, so don't make any change to HL, but increment quotient by 1
0311                          ; 
0311   7C                     MOV   A,H   
0312   B5                     ORA   L   
        **MACRO UNROLL - RST_JZPAGE
0313   E7 RST   4   ; assume it is on same page
0314                          ; because DivSub will
0314                          ; be right at end of page 2
0314   17                     DB   (DivNoRestore&0ffh)-1   
0315                          ; 
        **MACRO UNROLL - RST_NEGATEDE
0315   F7 RST   6   
0316   19                     DAD   D   
0317   0B                     DCX   B   
0318                          ; 
0318                DIVNORESTORE:   
0318   03                     INX   B   
0319   50                     MOV   D,B   
031A   59                     MOV   E,C   
031B                          ; 
031B   C1                     POP   B   
031C                          ; 
031C   F1                     POP   PSW   
031D   F0                     RP   
        **MACRO UNROLL - RST_NEGATEDE
031E   F7 RST   6   
031F                          ; 
031F   C9                     RET   
0320                          ; 
0320                          ; GetLine sits entirely in page 3
0320                          ; good - it uses RST_CompareJump in two
0320                          ; places, so be careful if moving it
0320                          ; Also it assumes ClassLookup on same page
0320                          ; as NoCharClass
0320                NLTESTTRUE:   
0320                          ; A contains 13 at this point
0320                          ; we want to ooutput line feed (10)
0320                          ; because H is 3, we can subtract this from A
0320   94                     SUB   H   
        **MACRO UNROLL - RST_PUTCHAR
0321   CF RST   1   
0322                          ; 
0322                          ; error if we are in the middle
0322                          ; of a string
0322   7D                     MOV   A,L   
        **MACRO UNROLL - RST_COMPAREJUMP
0323   DF RST   3   
0324   72                     DB   QuoteClassExpEnd&0ffh   
0325   06                     DB   (DivJZError-1)&0ffh   
0326                          ; 
0326   E1                     POP   H   
0327                          ; 
0327   C9                     RET   
0328                GETLINE:   
0328                          ; HL points where we want the line to be
0328                          ; parsed to.
0328                          ; On return HL points to byte adter what we've
0328                          ; got.
0328                          ; 
0328   3E 3E                  MVI   A,'>'   
        **MACRO UNROLL - RST_PUTCHAR
032A   CF RST   1   
032B                          ; 
032B   E5                     PUSH   H   
032C                          ; 
032C                          ; A is zero at this point
032C                          ; (needs to be <>10 on fall to NLTest)
032C                FRESHSTART:   
032C   21 5B 03               LXI   H,NoCharClass   
032F                          ; 
032F                NLTEST:   
032F   78                     MOV   A,B   
0330                          ; check for newline
        **MACRO UNROLL - RST_COMPAREJUMP
0330   DF RST   3   
0331   0D 1F                  DB   13,(NLTestTrue&0ffh)-1   
0333                          ; 
0333                NEXTCHARLOOP:   
0333                          ; This code is compatable with Stefan Tramm's
0333                          ; 8080 emulator
0333   DB 00                  IN   0   
0335   A7                     ANA   A   
        **MACRO UNROLL - RST_JZPAGE
0336   E7 RST   4   
0337   32                     DB   (NextCharLoop&0ffh)-1   
0338   DB 01                  IN   1   
033A   47                     MOV   B,A   
033B   D3 01                  OUT   1   ; echo
033D                          ; 
033D                          ; Do we have the same class as before?
033D   E5                     PUSH   H   
033E   2E B0                  MVI   L,(ClassLookup&0ffh)-1   
0340                          ; Test for quote first
0340                          ; This doesn't save spave, but takes 3 bytes
0340                          ; away from class lookip and puts them here
0340                          ; so can be used to change odd/even of
0340                          ; ...Class subroutines
        **MACRO UNROLL - RST_COMPAREJUMP
0340   DF RST   3   
0341   22 48                  DB   34,(LC_QuoteTestTrue-1)&0ffh   
0343                LOOKUPCLASSLOOP:   
0343   2C                     INR   L   
0344   BE                     CMP   M   
0345   2C                     INR   L   
0346   DA 43 03               JC   LookupClassLoop   
0349                LC_QUOTETESTTRUE:   
0349   4E                     MOV   C,M   
034A   E1                     POP   H   
034B                          ; 
034B                          ; are L and C equal?
034B   7D                     MOV   A,L   
034C   A9                     XRA   C   
034D                          ; Z if they are equal, NZ if not
034D   E9                     PCHL   ; Jump based on previous CharClass pointer
034E                DIGITCLASS:   
        **MACRO UNROLL - RST_JZPAGE
034E   E7 RST   4   
034F   5F                     DB   (DigitClassNotEnd&0ffh)-1   
0350                DIGITCLASSEND:   
0350                          ; Write token into program
0350                          ; need to preserve DE, don't care about HL
0350   E3                     XTHL   
0351   36 20                  MVI   M,IntegerToken   
0353   23                     INX   H   
0354   73                     MOV   M,E   
0355   23                     INX   H   
0356   36                     DB   36h   ; opcode for MVI M eats next byte
0357                WRITE_SHARED_ATSP:   
0357   D1                     POP   D   
0358                WRITE_SHARED:   
0358   72                     MOV   M,D   
0359                WRITE_SHARED_WRITTEN:   
0359   23                     INX   H   
035A   E3                     XTHL   
035B                NOCHARCLASS:   
035B   69                     MOV   L,C   
035C   AF                     XRA   A   ; set Z
035D   57                     MOV   D,A   ; reset state information
035E   5F                     MOV   E,A   
035F   E9                     PCHL   
0360                DIGITCLASSNOTEND:   
0360   E5                     PUSH   H   
0361                          ; A is zero at this point
0361                          ; Accumulate the value into D
0361                          ; Muliply by 10
0361   62                     MOV   H,D   
0362   6B                     MOV   L,E   
0363                          ; 
0363   29                     DAD   H   
0364   29                     DAD   H   
0365   19                     DAD   D   
0366   29                     DAD   H   
0367                          ; 
0367                          ; Add in the new digit
0367                          ; 
0367   57                     MOV   D,A   
0368   78                     MOV   A,B   
0369   E6 0F                  ANI   0fh   
036B   5F                     MOV   E,A   
036C   19                     DAD   D   
036D                          ; 
036D   EB                     XCHG   
036E                          ; 
036E   E1                     POP   H   
036F                          ; 
036F   C3 33 03               JMP   NextCharLoop   
0372                QUOTECLASSEXPEND:   
0372                          ; A is equal to:
0372                          ; char class (C) XOR QuoteCharClassExpEnd
0372                          ; 
0372                          ; so long as QuoteCharClass is the only class
0372                          ; with an odd address or the only one
0372                          ; with an even address then A will only
0372                          ; have LSB=1 if current char class
0372                          ; is QuoteCharClass - i.e. end of string
0372                          ; 
0372   E6                     DB   0e6h   ; opcode for ANI eats next byte
0373                          ; (which is 2dh lsbits are 01)
0373                          ; 
0373                QUOTECLASS:   
0373   2D                     DCR   L   ; set to QuoteClassExpEnd
0374                          ; first time through A is zero
0374                          ; on fall A is even unless C is QuoteClass
0374                          ; 
0374   A4                     ANA   H   ; H is 3
0375                          ; 
0375                          ; Now Z is set if this was first Quote, or if
0375                          ; we are in a string and haven't reached
0375                          ; last quote
0375                          ; 
0375                          ; carry is clear here
0375   DA                     DB   0dah   ; opcode for JC eats next 2 bytes
0376                LT0CLASS:   
0376   23                     INX   H   ; next char should always count as
0377                          ; different class
0377   00                     NOP   
0378                COMPCLASS:   
0378   00                     NOP   
0379   00                     NOP   
037A                ALPHACLASS:   
037A                          ; 
037A   E3                     XTHL   
037B   70                     MOV   M,B   
037C   23                     INX   H   
037D   E3                     XTHL   
037E                          ; 
037E   1B                     DCX   D   ; increase char count
037F                          ; 
037F                          ; if NZ then we will just
037F                          ; have written a different class char:
037F                          ; good, this ensures no spurious
037F                          ; strcmp matches from leftover
037F                          ; buffer contents
037F                          ; 
037F                          ; now we need to decide whether to jump to:
037F                          ; FreshStart - if its the last quote in
037F                          ;							 a string
037F                          ; NLTest		 - if part way through string or
037F                          ;								token
037F                          ; TokenClassEnd - if end of token
037F                          ; 
        **MACRO UNROLL - RST_JZPAGE
037F   E7 RST   4   
0380   2E                     DB   (NLTest&0ffh)-1   
0381                          ; 
0381   7D                     MOV   A,L   
        **MACRO UNROLL - RST_COMPAREJUMP
0382   DF RST   3   
0383   72 2B                  DB   QuoteClassExpEnd&0ffh,(FreshStart&0ffh)-1   
0385                          ; 
0385                TOKENCLASSEND:   
0385                          ; Make H point to the start of the token
0385                          ; to be looked up
0385   E3                     XTHL   
0386   19                     DAD   D   
0387                          ; 
0387                          ; it's a var if bits 7,6,5 are 010 and
0387                          ; E=-2
0387                          ; TODO These aren't the only conditions that
0387                          ; could lead to the test below passing -
0387                          ; e.g. if 7,6,5=001 and E=10011110.
0387   7E                     MOV   A,M   
0388   EE 40                  XRI   040h   
038A   57                     MOV   D,A   
038B   E6 E0                  ANI   0e0h   
038D   AB                     XRA   E   
038E                          ; 
        **MACRO UNROLL - RST_COMPAREJUMP
038E   DF RST   3   
038F   FE 57                  DB   0feh,(Write_Shared&0ffh)-1   
0391                          ; 
0391   11 B4 01               LXI   D,TokenList   
0394                LOOKUPTOKEN_LOOP:   
0394   1A                     LDAX   D   
0395   F5                     PUSH   PSW   
0396   E5                     PUSH   H   
0397                STRCMP:   
0397   13                     INX   D   
0398   1A                     LDAX   D   
0399   AE                     XRA   M   
039A                          ; iff match then A is either 00h or 80h
039A                          ; (80h if last char)
039A   23                     INX   H   
        **MACRO UNROLL - RST_JZPAGE
039B   E7 RST   4   
039C   96                     DB   (Strcmp&0ffh)-1   ; match and not last char
039D                          ; 
039D                          ; equal to 080h iff match and last char
039D   EE 80                  XRI   080h   
039F                          ; equal to Z iff match and last char
039F   E1                     POP   H   
03A0                          ; 
        **MACRO UNROLL - RST_JZPAGE
03A0   E7 RST   4   
03A1   56                     DB   (Write_Shared_AtSP&0ffh)-1   
03A2                          ; 
03A2   F1                     POP   PSW   
03A3                          ; 
03A3                LOOKUPTOKEN:   
03A3   1A                     LDAX   D   
03A4   3C                     INR   A   
03A5   13                     INX   D   
03A6   FA 94 03               JM   LookupToken_Loop   
03A9   C2 A3 03               JNZ   LookupToken   
03AC                          ; 
03AC                          ; didn't find it
03AC                          ; if (HL)>=64 and (HL+1)<64 then its a var
03AC                          ; could do the var test here
03AC                          ; if it can be done in few bytes
03AC                          ; 
03AC   36 21                  MVI   M,QuestionMarkToken&0ffh   
        **MACRO UNROLL - RST_JZPAGE
03AE   E7 RST   4   
03AF   58                     DB   (Write_Shared_Written&0ffh)-1   
03B0   73                     DB   QuoteClass&0ffh   
03B1                CLASSLOOKUP:   
03B1   40 7A                  DB   64,AlphaClass&0ffh   
03B3   3A 78                  DB   58,CompClass&0ffh   
03B5   30 4E                  DB   48,DigitClass&0ffh   
03B7   21 76                  DB   33,LT0Class&0ffh   
03B9   00 2C                  DB   0,FreshStart&0ffh   
03BB                GETLINENUM:   
03BB                          ; Line number is in DE, look it up in the program and set BC to the line num token
03BB                          ; DE is preserved
03BB                          ; H is preserved
03BB                          ; L is not preserved
03BB                          ; 
03BB                          ; return with Z set if successful
03BB                          ; 
03BB                          ; Z clear if not successful, and BC points
03BB                          ; to the first byte of the line with number
03BB                          ; greater than the request
03BB                          ; 
03BB   01 3F 10               LXI   B,PROG_BASE-1   ; 1 bytes before PROG_BASE
03BE                GETLINENUMLOOP:   
03BE   CD D7 03               CALL   ATNLN_INXB   ; has one INX B preceeding
03C1   C0                     RNZ   
03C2                          ; 
03C2   03                     INX   B   
03C3                          ; 
03C3                          ; Test for DE <= (BC), and return if true
03C3   0A                     LDAX   B   
03C4   03                     INX   B   
03C5   93                     SUB   E   
03C6   6F                     MOV   L,A   
03C7   0A                     LDAX   B   
03C8   9A                     SBB   D   ; C set if DE > (BC), and Z not set
03C9                          ; C clear if DE <= (BC)
03C9   DA BE 03               JC   GetLineNumLoop   
03CC                          ; 
03CC   0B                     DCX   B   
03CD   0B                     DCX   B   
03CE                          ; Now we want Z set if DE=(BC), clear
03CE                          ; otherwise
03CE                          ; 
03CE                ATNLN_RETNZ:   ; shared code. Returns NZ if we know
03CE                          ; that A is non-zero
03CE   B5                     ORA   L   
03CF                          ; 
03CF   C9                     RET   
03D0                ATNLN_STRING:   
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
03D0   D7 RST   2   
03D1   22                     DB   StringToken   
03D2   C2 D0 03               JNZ   ATNLN_String   
03D5                          ; 
03D5   C2                     DB   0c2h   ; opcode for JNZ eats 2 bytes
03D6                ATNLN_INT:   ; Z is always set when we reach here
03D6   03                     INX   B   
03D7                ATNLN_INXB:   
03D7   03                     INX   B   
03D8                          ; 
03D8                ADVANCETONEXTLINENUM:   
03D8                          ; BC is a pointer to somewhere in the program
03D8                          ; move onto the next line number
03D8                          ; return with Z set if successful
03D8                          ; Z clear if fell off end of program
03D8   0A                     LDAX   B   
        **MACRO UNROLL - RST_COMPAREJUMP
03D9   DF RST   3   
03DA   90 CD                  DB   EndProgram&0ffh,(ATNLN_RetNZ&0ffh)-1   
03DC                          ; fell off end of program
03DC                          ; 
03DC   FE 27                  CPI   LinenumSub&0ffh   
03DE   C8                     RZ   
03DF                          ; 
03DF   03                     INX   B   
03E0                          ; 
        **MACRO UNROLL - RST_COMPAREJUMP
03E0   DF RST   3   
03E1   20 D5                  DB   IntegerToken,(ATNLN_Int&0ffh)-1   
        **MACRO UNROLL - RST_COMPAREJUMP
03E3   DF RST   3   
03E4   22 CF                  DB   StringToken,(ATNLN_String&0ffh)-1   
03E6   C3 D8 03               JMP   AdvanceToNextLineNum   
03E9                FORSUBIMPL:   
03E9                          ; Stack contains return address:
03E9                          ; ExecuteProgramLoop - EPL
03E9                          ; Keep it there even though it isn't used by
03E9                          ; ForSub, it will be used by NextSub
03E9                          ; 
03E9                          ; 
03E9   E5                     PUSH   H   ; stack has var addr + 1 (VL+1), EPL
03EA                          ; 
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
03EA   D7 RST   2   
03EB                          ; 
03EB   A9                     DB   ToToken&0ffh   
03EC   C4 0A 04               CNZ   Error   
03EF                          ; 
03EF   CD 3B 00               CALL   ExpEvaluate   
        **MACRO UNROLL - RST_NEGATEDE
03F2   F7 RST   6   
03F3                          ; 
03F3   D5                     PUSH   D   ; stack contains -T,VL+1, EPL
03F4                          ; T is target
03F4                          ; 
03F4   11 01 00               LXI   D,1   
        **MACRO UNROLL - RST_LDAXB_INXB_CPI
03F7   D7 RST   2   
03F8   AA                     DB   StepToken&0ffh   
        **MACRO UNROLL - RST_JZPAGE
03F9   E7 RST   4   
03FA   FC                     DB   (ForWithStep&0ffh)-1   
03FB   0B                     DCX   B   
03FC   21                     DB   21h   ; LXI H opcode eats the next 2 bytes
03FD                          ; because ExpEvaluate is on page 0
03FD                          ; the 3rd byte is NOP
03FD                FORWITHSTEP:   
03FD                          ; we have step token
03FD   CD 3B 00               CALL   ExpEvaluate   
0400                          ; 
0400   E1                     POP   H   
0401   E1                     POP   H   
0402   C5                     PUSH   B   ; stack contains -T,LS,EPL
0403   3B                     DCX   SP   
0404   3B                     DCX   SP   
0405   D5                     PUSH   D   ; stack contains S,-T,LS,EPL
0406   E5                     PUSH   H   ; stack contains VL+1,S,-T,LS,EPL
0407                          ; 
0407   C3 96 02               JMP   ExecuteProgramLoop   
040A                ERROR:    
040A   CD A1 00               CALL   CRLF   
040D   3E 45                  MVI   A,'E'   
        **MACRO UNROLL - RST_PUTCHAR
040F   CF RST   1   
0410   D1                     POP   D   
0411   CD 8C 01               CALL   PrintInteger   
0414   C3 DB 00               JMP   Ready   


RAM_BASE:           1000 DEFINED AT LINE 308
                    > USED AT LINE 338
                    > USED AT LINE 342
                    > USED AT LINE 345
                    > USED AT LINE 346
                    > USED AT LINE 348
RAM_TOP:            1400 DEFINED AT LINE 309
                    > USED AT LINE 334
                    > USED AT LINE 335
INTEGERTOKEN:       0020 DEFINED AT LINE 315
                    > USED AT LINE 527
                    > USED AT LINE 778
                    > USED AT LINE 948
                    > USED AT LINE 1619
                    > USED AT LINE 1877
QUESTIONMARKTOKEN:  0021 DEFINED AT LINE 316
                    > USED AT LINE 1051
                    > USED AT LINE 1796
STRINGTOKEN:        0022 DEFINED AT LINE 317
                    > USED AT LINE 643
                    > USED AT LINE 706
                    > USED AT LINE 944
                    > USED AT LINE 1851
                    > USED AT LINE 1879
INPUT_BUFFER:       13F8 DEFINED AT LINE 334
                    > USED AT LINE 1169
STACK_INIT:         13F8 DEFINED AT LINE 335
                    > USED AT LINE 753
                    > USED AT LINE 1156
VAR_SPACE:          1000 DEFINED AT LINE 338
                    > USED AT LINE 678
PROG_PTR:           1000 DEFINED AT LINE 342
                    > USED AT LINE 371
                    > USED AT LINE 757
                    > USED AT LINE 798
                    > USED AT LINE 864
PROG_PARSE_PTR:     103C DEFINED AT LINE 345
                    > USED AT LINE 691
                    > USED AT LINE 765
                    > USED AT LINE 817
RNG_SEED:           103E DEFINED AT LINE 346
                    > USED AT LINE 1341
                    > USED AT LINE 1346
PROG_BASE:          1040 DEFINED AT LINE 348
                    > USED AT LINE 1262
                    > USED AT LINE 1303
                    > USED AT LINE 1820
PUTCHAR:            0008 DEFINED AT LINE 382
PUTCHARWAITLOOP:    000A DEFINED AT LINE 385
COMPAREJUMP_ENTRY:  0021 DEFINED AT LINE 435
                    > USED AT LINE 426
JZPAGE_SKIP:        0025 DEFINED AT LINE 438
                    > USED AT LINE 436
EXPAPPLYOP:         0026 DEFINED AT LINE 440
                    > USED AT LINE 570
                    > USED AT LINE 585
COMPAREHLDE:        0028 DEFINED AT LINE 449
NEGATEDE:           0030 DEFINED AT LINE 468
EXPEVALUATE:        003B DEFINED AT LINE 486
                    > USED AT LINE 735
                    > USED AT LINE 911
                    > USED AT LINE 1135
                    > USED AT LINE 1145
                    > USED AT LINE 1189
                    > USED AT LINE 1243
                    > USED AT LINE 1896
                    > USED AT LINE 1916
EXPEVALUATENUM:     0042 DEFINED AT LINE 504
                    > USED AT LINE 498
                    > USED AT LINE 620
                    > USED AT LINE 648
EXPINTEGER:         0057 DEFINED AT LINE 536
EXPVAR:             005B DEFINED AT LINE 543
                    > USED AT LINE 528
EXPVARGETVALUE:     005E DEFINED AT LINE 547
EXPEVALUATEOP:      0061 DEFINED AT LINE 552
                    > USED AT LINE 610
                    > USED AT LINE 718
SKIPEXPAPPLYOP:     0070 DEFINED AT LINE 588
                    > USED AT LINE 564
EXPNEGATE:          0077 DEFINED AT LINE 605
                    > USED AT LINE 512
PRINTSUBSTRING:     0086 DEFINED AT LINE 623
                    > USED AT LINE 643
PRINTSUBINTEGER:    0089 DEFINED AT LINE 625
                    > USED AT LINE 649
PRINTSUBLOOP:       008D DEFINED AT LINE 629
                    > USED AT LINE 645
PRINTSUBIMPL:       0090 DEFINED AT LINE 634
                    > USED AT LINE 1132
CRLF:               00A1 DEFINED AT LINE 656
                    > USED AT LINE 755
                    > USED AT LINE 979
                    > USED AT LINE 1929
GETVARLOCATIONBVAR: 00A8 DEFINED AT LINE 663
                    > USED AT LINE 1166
                    > USED AT LINE 1180
GETVARLOCATION:     00AD DEFINED AT LINE 670
                    > USED AT LINE 546
OUTPUTSTRINGRET:    00BB DEFINED AT LINE 696
                    > USED AT LINE 708
OUTPUTSTRING:       00BC DEFINED AT LINE 701
                    > USED AT LINE 624
OUTPUTSTRINGLOOP:   00BD DEFINED AT LINE 704
                    > USED AT LINE 712
OUTPUTSTRING_WITHQUOTE: 00C1 DEFINED AT LINE 709
                    > USED AT LINE 1031
EXPLEFTBRACE:       00C4 DEFINED AT LINE 714
                    > USED AT LINE 510
FUNCTIONCALL:       00C5 DEFINED AT LINE 716
                    > USED AT LINE 519
EXPBRACKETEDB:      00CD DEFINED AT LINE 730
                    > USED AT LINE 686
READY:              00DB DEFINED AT LINE 748
                    > USED AT LINE 833
                    > USED AT LINE 876
                    > USED AT LINE 1265
                    > USED AT LINE 1934
LINESTARTSWITHINT:  00F8 DEFINED AT LINE 781
DELETEPROGRAMLINE:  0119 DEFINED AT LINE 829
                    > USED AT LINE 803
ENTRY:              0129 DEFINED AT LINE 859
                    > USED AT LINE 827
MEMORYROTATE:       012D DEFINED AT LINE 866
REVERSEDH:          0137 DEFINED AT LINE 879
                    > USED AT LINE 874
REVERSE:            013A DEFINED AT LINE 884
                    > USED AT LINE 873
REVERSELOOP:        013A DEFINED AT LINE 888
                    > USED AT LINE 902
POPHASSIGNTOVAR_PREFIX: 0148 DEFINED AT LINE 904
                    > USED AT LINE 1172
POPHASSIGNTOVAR:    0151 DEFINED AT LINE 915
                    > USED AT LINE 1191
LISTLOOP:           0156 DEFINED AT LINE 927
                    > USED AT LINE 935
                    > USED AT LINE 1304
LIST_TOKEN_LOOP:    016E DEFINED AT LINE 955
                    > USED AT LINE 959
                    > USED AT LINE 966
LIST_TOKEN:         0174 DEFINED AT LINE 961
LIST_TOKEN_STRING_LOOP: 0179 DEFINED AT LINE 968
                    > USED AT LINE 974
LIST_LINENUM:       0183 DEFINED AT LINE 978
                    > USED AT LINE 946
LIST_INTEGER:       0186 DEFINED AT LINE 981
                    > USED AT LINE 948
PRINTINTEGER:       018C DEFINED AT LINE 991
                    > USED AT LINE 626
                    > USED AT LINE 1933
PRINTINTEGERLOOP:   0197 DEFINED AT LINE 1003
                    > USED AT LINE 998
                    > USED AT LINE 1021
PRINTINTEGERLOOP2:  01A7 DEFINED AT LINE 1023
                    > USED AT LINE 1028
LIST_STRING:        01AC DEFINED AT LINE 1030
                    > USED AT LINE 944
LIST_VAR:           01B0 DEFINED AT LINE 1034
                    > USED AT LINE 950
TOKENLIST:          01B4 DEFINED AT LINE 1050
                    > USED AT LINE 939
                    > USED AT LINE 1756
LINENUMSUB:         0227 DEFINED AT LINE 1126
                    > USED AT LINE 815
                    > USED AT LINE 946
                    > USED AT LINE 1272
                    > USED AT LINE 1276
                    > USED AT LINE 1281
                    > USED AT LINE 1871
PRINTSUB:           022A DEFINED AT LINE 1131
                    > USED AT LINE 617
                    > USED AT LINE 723
                    > USED AT LINE 1053
GOSUBSUB:           022D DEFINED AT LINE 1134
                    > USED AT LINE 1059
GOTOSUB:            0234 DEFINED AT LINE 1144
                    > USED AT LINE 1057
RETURNSUB:          023E DEFINED AT LINE 1153
                    > USED AT LINE 1061
INPUTSUB:           0248 DEFINED AT LINE 1164
                    > USED AT LINE 1063
FORSUB:             0253 DEFINED AT LINE 1174
                    > USED AT LINE 1065
LETSUB:             0257 DEFINED AT LINE 1179
                    > USED AT LINE 1055
NEXTSUB:            0266 DEFINED AT LINE 1193
                    > USED AT LINE 1067
NEXTSUBLOOP:        027E DEFINED AT LINE 1232
                    > USED AT LINE 1226
IFSUB:              0286 DEFINED AT LINE 1242
                    > USED AT LINE 1069
EXECUTEPROGRAM:     028F DEFINED AT LINE 1251
                    > USED AT LINE 369
                    > USED AT LINE 1075
ENDPROGRAM:         0290 DEFINED AT LINE 1254
                    > USED AT LINE 763
                    > USED AT LINE 776
                    > USED AT LINE 802
                    > USED AT LINE 932
                    > USED AT LINE 1868
ENDSUB:             0293 DEFINED AT LINE 1264
                    > USED AT LINE 1071
EXECUTEPROGRAMLOOP: 0296 DEFINED AT LINE 1267
                    > USED AT LINE 1286
                    > USED AT LINE 1926
EXECUTEDIRECT:      0297 DEFINED AT LINE 1270
                    > USED AT LINE 779
NEWSUB:             02A7 DEFINED AT LINE 1299
                    > USED AT LINE 1079
LISTSUB:            02A8 DEFINED AT LINE 1302
                    > USED AT LINE 1077
                    > USED AT LINE 1276
                    > USED AT LINE 1309
                    > USED AT LINE 1310
                    > USED AT LINE 1311
                    > USED AT LINE 1312
TOTOKEN:            02A9 DEFINED AT LINE 1309
                    > USED AT LINE 1094
                    > USED AT LINE 1893
STEPTOKEN:          02AA DEFINED AT LINE 1310
                    > USED AT LINE 1096
                    > USED AT LINE 1905
RIGHTBRACETOKEN:    02AB DEFINED AT LINE 1311
                    > USED AT LINE 738
                    > USED AT LINE 1102
COMMATOKEN:         02AC DEFINED AT LINE 1312
                    > USED AT LINE 645
                    > USED AT LINE 1098
ABSSUB:             02AE DEFINED AT LINE 1314
                    > USED AT LINE 518
                    > USED AT LINE 1087
                    > USED AT LINE 1471
LEFTBRACETOKEN:     02B1 DEFINED AT LINE 1326
                    > USED AT LINE 508
                    > USED AT LINE 732
                    > USED AT LINE 1100
USRSUB:             02B2 DEFINED AT LINE 1329
                    > USED AT LINE 1089
RNDSUB:             02B4 DEFINED AT LINE 1334
                    > USED AT LINE 515
                    > USED AT LINE 1091
OPERATORS:          02CB DEFINED AT LINE 1389
                    > USED AT LINE 594
LTESUB:             02CB DEFINED AT LINE 1391
                    > USED AT LINE 1110
GTESUB:             02CC DEFINED AT LINE 1394
                    > USED AT LINE 1108
GTSUB:              02CF DEFINED AT LINE 1398
                    > USED AT LINE 1114
LTSUB:              02D0 DEFINED AT LINE 1401
                    > USED AT LINE 1112
EQUALSUB:           02D9 DEFINED AT LINE 1412
                    > USED AT LINE 1104
                    > USED AT LINE 1186
BINRETURN:          02DA DEFINED AT LINE 1414
                    > USED AT LINE 1397
NOTEQUALSUB:        02DC DEFINED AT LINE 1418
                    > USED AT LINE 1106
ADDSUB:             02E3 DEFINED AT LINE 1425
                    > USED AT LINE 1116
SUBSUB:             02E4 DEFINED AT LINE 1427
                    > USED AT LINE 512
                    > USED AT LINE 1118
MULSUB:             02E8 DEFINED AT LINE 1435
                    > USED AT LINE 570
                    > USED AT LINE 1120
                    > USED AT LINE 1343
MULTIPLY:           02EB DEFINED AT LINE 1442
MULLOOP:            02ED DEFINED AT LINE 1445
                    > USED AT LINE 1455
DONTADD:            02F5 DEFINED AT LINE 1452
                    > USED AT LINE 1450
DIVSUB:             02FC DEFINED AT LINE 1461
                    > USED AT LINE 1122
DIVIDEHL:           02FC DEFINED AT LINE 1467
                    > USED AT LINE 1010
                    > USED AT LINE 1353
DIVJZERROR:         0307 DEFINED AT LINE 1488
                    > USED AT LINE 1543
DIVLOOP:            030A DEFINED AT LINE 1491
                    > USED AT LINE 1497
DIVNORESTORE:       0318 DEFINED AT LINE 1512
                    > USED AT LINE 1506
NLTESTTRUE:         0320 DEFINED AT LINE 1531
                    > USED AT LINE 1571
GETLINE:            0328 DEFINED AT LINE 1549
                    > USED AT LINE 761
                    > USED AT LINE 908
FRESHSTART:         032C DEFINED AT LINE 1563
                    > USED AT LINE 1733
                    > USED AT LINE 1806
NLTEST:             032F DEFINED AT LINE 1567
                    > USED AT LINE 1729
NEXTCHARLOOP:       0333 DEFINED AT LINE 1573
                    > USED AT LINE 1579
                    > USED AT LINE 1667
LOOKUPCLASSLOOP:    0343 DEFINED AT LINE 1594
                    > USED AT LINE 1598
LC_QUOTETESTTRUE:   0349 DEFINED AT LINE 1599
                    > USED AT LINE 1593
DIGITCLASS:         034E DEFINED AT LINE 1610
                    > USED AT LINE 1804
DIGITCLASSEND:      0350 DEFINED AT LINE 1614
WRITE_SHARED_ATSP:  0357 DEFINED AT LINE 1624
                    > USED AT LINE 1779
WRITE_SHARED:       0358 DEFINED AT LINE 1626
                    > USED AT LINE 1754
WRITE_SHARED_WRITTEN: 0359 DEFINED AT LINE 1628
                    > USED AT LINE 1798
NOCHARCLASS:        035B DEFINED AT LINE 1632
                    > USED AT LINE 1565
DIGITCLASSNOTEND:   0360 DEFINED AT LINE 1640
                    > USED AT LINE 1612
QUOTECLASSEXPEND:   0372 DEFINED AT LINE 1669
                    > USED AT LINE 1542
                    > USED AT LINE 1733
QUOTECLASS:         0373 DEFINED AT LINE 1683
                    > USED AT LINE 1800
LT0CLASS:           0376 DEFINED AT LINE 1698
                    > USED AT LINE 1805
COMPCLASS:          0378 DEFINED AT LINE 1703
                    > USED AT LINE 1803
ALPHACLASS:         037A DEFINED AT LINE 1706
                    > USED AT LINE 1802
TOKENCLASSEND:      0385 DEFINED AT LINE 1735
LOOKUPTOKEN_LOOP:   0394 DEFINED AT LINE 1758
                    > USED AT LINE 1787
STRCMP:             0397 DEFINED AT LINE 1762
                    > USED AT LINE 1770
LOOKUPTOKEN:        03A3 DEFINED AT LINE 1783
                    > USED AT LINE 1788
CLASSLOOKUP:        03B1 DEFINED AT LINE 1801
                    > USED AT LINE 1586
GETLINENUM:         03BB DEFINED AT LINE 1808
                    > USED AT LINE 796
                    > USED AT LINE 1146
GETLINENUMLOOP:     03BE DEFINED AT LINE 1822
                    > USED AT LINE 1836
ATNLN_RETNZ:        03CE DEFINED AT LINE 1843
                    > USED AT LINE 1868
ATNLN_STRING:       03D0 DEFINED AT LINE 1849
                    > USED AT LINE 1852
                    > USED AT LINE 1879
ATNLN_INT:          03D6 DEFINED AT LINE 1855
                    > USED AT LINE 842
                    > USED AT LINE 1877
ATNLN_INXB:         03D7 DEFINED AT LINE 1857
                    > USED AT LINE 1823
ADVANCETONEXTLINENUM: 03D8 DEFINED AT LINE 1860
                    > USED AT LINE 1249
                    > USED AT LINE 1880
FORSUBIMPL:         03E9 DEFINED AT LINE 1882
                    > USED AT LINE 1175
FORWITHSTEP:        03FD DEFINED AT LINE 1914
                    > USED AT LINE 1907
ERROR:              040A DEFINED AT LINE 1928
                    > USED AT LINE 499
                    > USED AT LINE 668
                    > USED AT LINE 733
                    > USED AT LINE 744
                    > USED AT LINE 808
                    > USED AT LINE 1148
                    > USED AT LINE 1158
                    > USED AT LINE 1187
                    > USED AT LINE 1277
                    > USED AT LINE 1489
                    > USED AT LINE 1894
